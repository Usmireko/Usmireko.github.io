{"pages":[{"title":"404","text":"","path":"404/index.html","date":"03-30","excerpt":""},{"title":"about","text":"哈三中最菜OIer(不接受反驳)东方狗一枚还是个DDstg进度: yycl(为啥我这么弱) 在打幕华祭春雪篇崇拜的人:VCodelxlzz本命:宇佐见莲子(莲子是第一生产力)目标:学会lua然后学ZUN神做一部stg+女装一回","path":"about/index.html","date":"03-07","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-18","excerpt":""},{"title":"tag","text":"type: “tags”","path":"tag/index.html","date":"03-07","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-30","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-18","excerpt":""},{"title":"yourdiy","text":"","path":"yourdiy/index.html","date":"03-07","excerpt":""}],"posts":[{"title":"Hexo的伪进阶教程","text":"前面几位dalao已经把如何搭建博客以及一些基础设置讲的足够明白了，因此这里就不再提及了。本菜鸡在搭完博客后还想进一步优化博客，然后就一jio栽进坑里。 1.开始优化前的准备—-hexo-admin我是不太喜欢直接在.md文件里写博客的，如果语法出了问题，改起来很麻烦。使用hexo-admin插件可以简便的管理文章。 下面#define AD hexo-admin AD官网 在Git Bash中输入npm install –save hexo-admin安装完之后先检查一下在GitBash中输入hexo server -d 启动服务器在浏览器中打开 http://localhost:4000/admin/它是这个样子如果想加个用户名和密码啥的，打开hexo根目录配置文件 admin: username://用户名 password_hash://用户名密码不喜欢的可以不设置，这里通过bcrypt hash secret: hey hexo deploy//用以cookies安全； Command: 点击博客编辑页面右上角的“+”，就可以方便的添加标签和分类了之后的所有步骤都可以使用AD创建测试页 2.搭建完博客之后马上就会遇到的部分问题(有一定概率发生)没有分类打开 主题文件夹/_config.yml,在其中找到”menu”，将”#categories: /categories/ || th”的#删除，重新加载博客即可 关于,标签,分类不能使用这里指的不能使用是指在点击标签等按钮时弹出以下页面: Cannot GET /tags/ 在Git Bash中输入 hexo new page tags确认站点配置文件里有 tag_dir: tags确认主题配置文件里有 tags: /tags点开博客文件夹 /source/tags/index.md此时它应该是这样的:在开头和结尾的”—“中间加入: title: &quot;tags&quot; type: tags 然后另存为当前文件夹(如果在index文件里有中文字符，则一定注意编码选择UTF-8)分类和关于同上 hexo g，博客没有更新内容很奇葩的一个问题，但是的确坑到了我解决办法:hexo g-&gt;hexo d-&gt;hexo g-&gt;hexo d很暴力但是很有用，在第二遍hexo d时可以看见有新的改变添加到博客中个人觉得是hexo g有时会偷懒 upd 3-22更新 hexo g问题下面介绍的两种自动发布博客的方法解决了hexo g的问题 3.开始优化终于可以开始优化了 实现自动发布文章这里使用给出linux系统和windows系统下的不同处理方式 linux使用admin+脚本实现在hexo根目录编辑文件里加入 Command: &#39;./admin_script/hexo-generate.sh&#39; # expire: 60*1 在根目录新建admin_script，文件夹，进入执行 touch hexo-generate.sh; vim hexo-generate.sh; 输入 #!/usr/bin/env sh hexo clean hexo g -d//有什么其他想自动化的操作也可以写进去 修改权限 chmod +x hexo-generate.sh windows使用.bat实现在hexo安装目录下新建deploy.bat,输入 call cd source/_posts git pull origin master cd ../../ hexo g -d 测试一下:双击.bat然后等一会。。。。 评论区这里使用Valine实现注：由于next主题自带Valine，所以配置起来可能和其他主题不同 注册Leancloud官网注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey 修改配置文件打开/theme/_config.yml找到valine行 valine: enable: true appid: your app id appkey: your app key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 在这里输入评论daze~ guest_info: nick,mail,link pageSize: 10 打开Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名里填博客链接地址hexo g hexo d然后就可以被吐槽了 4.开始美化美化才是最费时最费力的可能会用到一定的css&amp;html&amp;ps基础 随机图片背景由于本菜鸡不会html,所以只能用随机图片接口QAQ如果有神仙知道请一定要指导一下 背景图片轮播使用jquery-backstretch插件实现下面#define JQ jquery-backstretch JQ–引用JQ插件打开 themes\\next\\layout_custom\\custom-foot.swig 没有？新建一个啊 &lt;!-- 图片轮播js文件cdn --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 自定义的js文件 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/custom.js&quot;&gt;&lt;/script&gt; 打开themes\\next\\source\\js\\src\\custom.js $(function () { $.backstretch([ 。。。。 ], { duration: 60000, fade: 1500 }); }); 。。。。处填图片地址，duration是轮播时间，fade是指轮换图片花费的时间。 代码高亮hexo自带的代码高亮已经能够满足大部分OIer的需求，但是对于像我们机房的VCode这种精通十六国语言的人来说，这种代码高亮是远远不够的。这里只介绍Google Prettify，其他像highlight的请类比或自行百度。打开/博客根目录/_config.yml找到highlight一行，将其改为 highlight: enable: false line_number: false auto_detect: false tab_replace: 下载prettify下载后解压到theme/next/source/lib文件夹中(推荐将文件夹重命名为Prettify)选一个自己喜欢的主题吧！下载自己喜欢的主题文件到lib/prettify/skins目录下。在主题的layout/_third-party目录下创建prettify.swig文件，添加以下代码 &lt;link rel=&quot;stylesheet&quot; href=&quot;/lib/prettify/skins/{{ theme.custom_highlight_theme }}.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;/lib/prettify/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() { $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint(); }); &lt;/script&gt; 修改主题layout目录下的_layout.swig文件，在合适的地方（在&lt; body &gt;里面）添加： {% include '_third-party/prettify.swig' %} 修改主题的_config.yml文件，添加一行： custom_highlight_theme: 。。。 。。。是主题名 动态交互式背景其实这东西对密集恐惧症不友好打开/themes/_config.yml,找到以下代码 # three_waves three_waves: false # canvas_lines canvas_lines: false # canvas_sphere canvas_sphere: false 这是自带的三种动态交互式背景 针对canvas_lines线条颜色过淡的解决办法这里使用暴力打开/themes/source/lib/three/canvas_lines.min.js爆炸吧！！！！！（由于原图太爆炸无法显示，在这里以部分代码的形式展现） this.color=new THREE.Color(16777215),this.program=function(e,t){},this.setValues(e)}, THREE.SpriteCanvasMaterial.prototype=Object.create(THREE.Material.prototype), THRE.SpriteCanvasMaterial.prototype.constructor=THREE.SpriteCanvasMaterial,THREE.SpriteCanvas Material.prototype.clone=function(){var e=new THREE.SpriteCanvasMaterial;return e.copy(this),e.color.copy(this.color), e.program=this.program,e},THREE.Canva 所以说刚点开时会有非同一般的视觉冲击感。但是，请看第一行开头括号里的数字这串数字就是颜色的10进制码！(我的是改过的，没有改过的应该是灰白色对应的码)然后暴力把颜色码替换成想要的颜色码就可以了(鬼知道我是怎么搞出来的) L2d设置(z16我tm吹爆!)ei you wo cao，zhe shi hao de先选择自己社保喜欢的小姐姐，记好名字 预览这里以z16为例先在Git Bash里输入npm install –save hexo-helper-live2d然后打开/theme/_config.yml添加以下代码(名字自行更换) live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-z16 display: position: right width: 150 height: 300 mobile: show: true 下载模型 npm install live2d-widget-model-z16 下载完之后，在博客根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中，然后打开博客根目录下的——config.yml，找到model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。然后！！！！！！！！！(这里有张z16小姐姐的gif图)(为了防止部分小朋友康不到,特在此说明)我哭了 5.完结撒花未完待续或许以后会填上的坑自定义域名更换服务器静态博客压缩鼠标样式和点击样式好了我去打春雪篇了 TO BE CONTINUED","path":"2019/03/22/Untitled/","date":"03-22","excerpt":"","tags":[{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/博客搭建/"}]},{"title":"回文自动机","text":"回文自动机是一种专门处理回文串问题的数据结构，于2014年于俄罗斯提出（战斗民族自动机）。事实上，对于大部分回文串问题，可以用manacher算法A掉，但是对于那些懒得想乱搞，只喜欢用暴力方法骗分的蒟蒻（对就是在说我），回文自动机是一个非常好的选择。其优秀的nlogn时间复杂度和强大的处理能力使许多需要manacher+乱搞的题变成了回文自动机裸题。 好，那么就让我们一起看一看三大有限机之一—–回文自动机的工作原理吧 1.回文自动机的前置技能 如果你了解AC自动机，那么理解fail指针部分应该不需要花费太多时间。如果你不会AC自动机，那么你需要了解KMP算法中next数组的原理 如果你什么都不知道，而且懒得去看博客，那么你可能需要背板子了（没错就是在说我） 2.回文自动机的组成 回文自动机由一颗奇回文树和一颗偶回文树构成，每个节点代表一个回文子串，节点间用fail指针相连 3.回文自动机的内部构造 (1)回文自动机的组成部分 const long long maxn=300005; long long s[maxn],next[maxn][26],len[maxn],cnt[maxn],fail[maxn]; long long last,p,n; char ss[maxn]; ss为输入的字符串，s记录新插入的节点，len[i]表示i回文串的长度，cnt[i]表示i回文串在字符串(ss)里出现的次数。 last是以字符串中上一个位置(即i-1)结尾的回文串编号，p是新建节点编号，n是新加入字符编号。 那么next是什么呢？看到next是不是有点熟悉？没错，它代表的就是节点i代表的回文串在两边添加字符c以后变成的回文串的编号。 （所以学好KMP很重要） (2)回文自动机的初始化 既然回文自动机是两棵树，那么我们就需要链式前向星来建树。。。啊，不好意思走神了。 那么，还是用解释代码的方式来吧 void init(){ p=fail[0]=1; last=n=0; s[0]=len[1]=-1; } last,n不用解释吧 s[0]=-1是向字符串里加一个没有的字符，减少特判。 len[0]=0,len[1]=-1是初始化奇回文树和偶回文树的根节点长度。为什么我们把奇回文树的根节点长度设为-1呢？其实是简化之后长度为1的回文串的处理而精心构造的。（我口胡的） p=1，因为有一个节点了(0)，fail[0]=1则是用fail指针将回文树连起来。 (3)回文自动机的构造方式+工作原理 void add(long long c){ c-=&#39;a&#39;;s[++n]=c; long long cur=get_fail(last); if(!next[cur][c]){ fail[++p]=next[get_fail(fail[cur])][c]; next[cur][c]=p; len[p]=len[cur]+2; } last=next[cur][c]; ++cnt[last]; } 哇，回文自动机核心竟然这~么短！惊不惊喜意不意外！ 咳，说正事。这就是回文自动机的内部结构了。首先传进来一个字符，将它放进s里，编号n+1。 然后。。。诶怎么有个get_fail函数? long long get_fail(long long x){ while(s[n-len[x]-1]!=s[n])x=fail[x]; return x; } 学过ac自动机的小朋友一定对fail有很深的印象吧。事实上，回文自动机也是通过fail指针失配后回跳到上一个节点继续匹配的。get_fail函数就是判断回跳到的节点所代表的串是否为回文串，如果不是则继续跳，直到回到合法节点。 那么，当我们找出last的fail指针指向的节点（回文串）后，检查向它收尾加入c字符后形成的字符串是否已经存在。若不存在，则新建节点（节点编号p+1），该节点的fail指针指向向当前节点的fail指针指向的节点的fail指针指向的节点尾加入c字符后形成的节点（大家：你在说什么）。 这是什么呢？让我们好好想一想。用代码来说，cur是当前节点编号最大的节点的失配节点，那么，如果next[cur][c]存在，它就和last相等了。不存在，就新建节点，并将其保存在其中。然后，由于cur是个字符串，所以不能把c+cur的fail指向fail[cur]（要不然就不是奇偶回文树了），而是get_fail(fail[cur])。 然后就是加边，更新长度。最后记一下last，节点为last的数量++ 当然，这样求出来的数量并非真实数量（因为大字符串可以包含小字符串），所以我们还需要count函数，倒着加一遍。 long long count(){ for(long long i=p;i&gt;=0;--i){ cnt[fail[i]]+=cnt[i]; } } 4.回文自动机求出的结果 说了这么多，回文自动机到底是求啥的？ 回文自动机最牛逼的地方就是可以求出一个字符串中所有不同种类的字符串（本质不同的字符串），以及每一种字符串出现的次数。 所以，凡是遇到回文串的题，用回文自动机扫过去，就可以将一个充满回文子串的毒瘤字符串扒的一干二净（迫真战斗民族）。 最后放个代码我就跑了（ #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; const long long maxn=300005; long long s[maxn],next[maxn][26],len[maxn],cnt[maxn],num[maxn],fail[maxn]; long long last,p,n; char ss[maxn]; void init(){ p=1,last=0,n=0,s[0]=-1,fail[0]=1,len[1]=-1; } long long get_fail(long long x){ while(s[n-len[x]-1]!=s[n])x=fail[x]; return x; } void add(long long c){ c-=&#39;a&#39;;s[++n]=c; long long cur=get_fail(last); if(!next[cur][c]){ fail[++p]=next[get_fail(fail[cur])][c]; next[cur][c]=p; len[p]=len[cur]+2; } last=next[cur][c]; ++cnt[last]; } long long count(){ for(long long i=p;i&gt;=0;--i){ cnt[fail[i]]+=cnt[i]; } } int main(){ scanf(&quot;%s&quot;,ss); long long len=strlen(ss); init(); for(long long i=0;i&lt;len;i++)add(ss[i]); printf(&quot;%lld&quot;,count()); }","path":"2019/03/12/回文自动机/","date":"03-12","excerpt":"","tags":[{"name":"代码","slug":"代码","permalink":"http://yoursite.com/tags/代码/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","path":"2019/03/06/hello-world/","date":"03-06","excerpt":"","tags":[]}]}